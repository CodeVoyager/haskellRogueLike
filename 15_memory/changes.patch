Common subdirectories: ../14_utility_annotate/src/Data and ./src/Data
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/src/GameCore.hs ./src/GameCore.hs
--- ../14_utility_annotate/src/GameCore.hs	2018-03-04 08:48:45.604622557 +0200
+++ ./src/GameCore.hs	2018-03-04 09:15:50.420964801 +0200
@@ -17,6 +17,7 @@
 import           Control.Lens.TH (makeLenses)
 import           Control.Monad.Writer.Strict (Writer)
 
+import qualified Memory as M
 import qualified GameHost as Host
 import qualified EntityType as E
 import qualified BoundedInt as B
@@ -44,10 +45,15 @@
                    --    Note that the world is threaded through the utilities and can be updated (i.e. in the ([], World) result)
                    --    The array of results has an updated actor and a score. These are speculative, and are only applied
                    --    if that utility is selected. The world updates are kept even if nothing is selected
+                   --    This is required because a utility may add a memory even if it can't move and that memory must be kept
+                   --    until its TTL expires
                    , _acUtilities :: ![World -> Actor -> [PathTo] -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)]
                    
                    -- | The actor's disposition - the values that define the actors personality
                    , _acDisposition :: !Disposition
+
+                   -- | The actor's memory about positions
+                   , _acPosMemory :: !(M.Memory WorldPos)
                    }
 
 data Player = Player { _plConn :: !Host.Connection
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/src/GameEngine.hs ./src/GameEngine.hs
--- ../14_utility_annotate/src/GameEngine.hs	2018-03-04 08:36:52.190404120 +0200
+++ ./src/GameEngine.hs	2018-03-04 10:30:29.663042181 +0200
@@ -24,6 +24,7 @@
 import           Control.Monad.Writer.Strict (runWriter)
 import           Control.Concurrent.STM (atomically, readTVar, newTVar, modifyTVar', TVar)
 
+import qualified Memory as M
 import           GameCore
 import qualified GameHost as Host
 import           GameHost (conSendData, conReceiveText)
@@ -166,6 +167,7 @@
             , _acEnergy = B.new 200 100
             , _acUtilities = []
             , _acDisposition = UB.emptyDisposition
+            , _acPosMemory = M.empty
             }
 
     mkEnemyActor aid e (x, y) =
@@ -182,6 +184,7 @@
             , _acEnergy = B.new 180 100
             , _acUtilities = []
             , _acDisposition = UB.emptyDisposition 
+            , _acPosMemory = M.empty
             }
     
 
@@ -732,6 +735,7 @@
           >>= checkIfNonMove
           >>= checkIfPlayerHasMinEnergy
           >>= runPendingIfPlayerHasEnergy
+          >>= runPlayerTick -- run the tick for the player, this is only run if the move was allowed
           >>= stopIfPlayerCanStillMove
   in
   case playerAttemptedMoveWorld of
@@ -765,6 +769,9 @@
         -- disallow
         Left w
 
+    runPlayerTick w =
+      Right $ w & (wdPlayer . plActor) %~ actorTick
+
     stopIfPlayerCanStillMove w =
       let
         a = w ^. wdPlayer ^. plActor 
@@ -935,3 +942,8 @@
     (\a g -> Map.insert (a ^. acWorldPos) (a ^. acEntity) g)
     (w ^. wdMap)
     (getAllActors w)
+
+  
+actorTick :: Actor -> Actor
+actorTick a =
+  a & acPosMemory %~ M.tick
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/src/Memory.hs ./src/Memory.hs
--- ../14_utility_annotate/src/Memory.hs	1970-01-01 02:00:00.000000000 +0200
+++ ./src/Memory.hs	2018-03-04 08:58:27.497352295 +0200
@@ -0,0 +1,79 @@
+{-# LANGUAGE NoImplicitPrelude #-}
+
+module Memory ( Memory
+              , empty
+              , remember
+              , recall
+              , forget
+              , forgetAll
+              , remembers
+              , tick
+              , toList
+              , fromList
+              ) where
+
+import Protolude hiding (Map, empty, toList)
+import qualified Data.Map.Strict as Map
+import           Data.Map.Strict (Map)
+
+-- | Store (remembers) values for a given period (measured by ticks)
+newtype Memory a = Memory (Map Text (Map a Int)) 
+
+
+empty :: Memory a
+empty = Memory Map.empty
+
+
+remember :: (Ord a) => (Int -> Int -> Int) -> Text -> Int -> a -> Memory a -> Memory a
+remember combineFn key ttl val (Memory m) =
+  Memory $ Map.alter ins key m
+
+  where
+    ins Nothing = Just $ Map.singleton val ttl
+    ins (Just vs) = Just $ Map.insertWith combineFn val ttl vs
+
+
+recall :: Text -> Memory a -> Map a Int
+recall key (Memory m) =
+  fromMaybe Map.empty $ Map.lookup key m 
+
+
+forgetAll :: Text -> Memory a -> Memory a
+forgetAll key (Memory m) =
+  Memory $ Map.delete key m
+
+
+forget :: (Ord a) => Text -> a -> Memory a -> Memory a
+forget key val (Memory m) =
+  Memory $ Map.alter rm key m
+
+  where
+    rm Nothing = Nothing
+    rm (Just vs) = Just $ Map.delete val vs
+
+
+remembers :: (Ord a) => Text -> a -> Memory a -> Bool
+remembers key val m =
+  Map.member val (recall key m)
+
+
+tick :: (Ord a) => Memory a -> Memory a
+tick (Memory m) =
+  Memory $ tickBucket <$> m
+  
+  where
+    tickBucket :: (Ord a) => Map a Int -> Map a Int
+    tickBucket vs =
+      foldr (Map.alter tickVal) vs (Map.keys vs)
+
+    tickVal :: Maybe Int -> Maybe Int
+    tickVal Nothing = Nothing
+    tickVal (Just i) = if i - 1 <= 0 then Nothing else Just (i - 1)
+    
+
+toList :: Memory a -> [(Text, [(a, Int)])]
+toList (Memory m) = Map.toList $ Map.toList <$> m
+
+
+fromList :: (Ord a) => [(Text, [(a, Int)])] -> Memory a
+fromList vs = Memory . Map.fromList $ Map.fromList <<$>> vs
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/src/UtilityBrain.hs ./src/UtilityBrain.hs
--- ../14_utility_annotate/src/UtilityBrain.hs	2018-03-04 08:38:43.212757698 +0200
+++ ./src/UtilityBrain.hs	2018-03-04 10:42:57.885580866 +0200
@@ -3,6 +3,7 @@
 {-# LANGUAGE OverloadedStrings #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE LambdaCase #-}
 
 module UtilityBrain ( selectTopUtility
                     , assessUtilities
@@ -13,6 +14,7 @@
                     ) where
 
 import Protolude 
+import qualified Data.Map.Strict as Map
 import qualified Data.List as Lst
 import qualified Data.DList as DLst
 import qualified System.Random as Rnd
@@ -20,6 +22,7 @@
 import           Control.Lens
 import           Control.Monad.Writer.Strict (tell, MonadWriter)
 
+import qualified Memory as M
 import           GameCore
 import qualified EntityType as E
 
@@ -32,6 +35,9 @@
 path (PathToActor p _ _) = p
 path (PathToPlayer p _ _) = p
 
+pathPs :: Path -> [WorldPos]
+pathPs (Path p) = p
+
 selectTopUtility :: [(Float, Actor, Impulse, Text, Maybe PathTo)]
                  -> UtilAnnotator (Maybe (Float, Actor, Impulse, Text, Maybe PathTo))
 selectTopUtility rs = do
@@ -135,12 +141,30 @@
 
 
 utilityOfWanderToExit :: World -> Actor -> [PathTo] -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)
-utilityOfWanderToExit world actor allPaths = do
+utilityOfWanderToExit world actor' allPaths = do
   telld $ UeAt "WanderToExit"
+  telld . UeNote $ "at: " <> show (actor' ^. acWorldPos)
+  telld . UeNote $ "goal: " <> show (M.recall "wanderToExit.goal" $ actor' ^. acPosMemory)
+  telld . UeNote $ "avoid: " <> show (M.recall "wanderToExit.avoid" $ actor' ^. acPosMemory)
 
-  let rule x = clamp $ 1 - (0.04 * x + (1.24 - clamp (actor ^. acDisposition ^. dsWanderlustToExits))) 
-  let clampedResults = moveTowardsUtil [E.Door] rule allPaths actor
-  pure ((\(p, score) -> (score, actor, ImpMoveTowards (path p), "wander to exit", Just p)) <$> clampedResults, world)
+  let rule x = clamp $ 1 - (0.04 * x + (1.24 - clamp (actor' ^. acDisposition ^. dsWanderlustToExits))) 
+
+  -- Find exits
+  let goalPaths = onlyEntitiesOfType [E.Door] allPaths 
+
+  let seek actor paths = do
+        -- Normalise distances
+        let pathsNormalisedMay = (\p -> (p, distanceToRange p (actor ^. acFovDistance))) <$> paths 
+        let pathsNormalised = catNormalisedMay pathsNormalisedMay 
+        -- Run utility calculation
+        let results = Ar.second rule <$> pathsNormalised 
+        let clampedResults = Ar.second clamp <$> results
+        -- Result
+        (\(p, score) -> (score, actor, ImpMoveTowards (path p), "wander to exit", Just p)) <$> clampedResults
+  
+  r <- seekGoal "wanderToExit" world actor' goalPaths seek
+  telld . UeNote $ "res.len= " <> show (length r)
+  pure r
 
   
 utilityOfInfatuation :: World -> Actor -> [PathTo] -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)
@@ -157,6 +181,92 @@
   pure ((\(p, score) -> (score, actor, ImpMoveTowards (path p), "infatuation", Just p)) <$> clampedResults, world)
 
 
+seekGoal :: Text     -- ^ prefix for memory storage
+         -> World
+         -> Actor    -- ^ the moving actor
+         -> [PathTo] -- ^ filtered paths, any one of which is a valid goal
+         -> (Actor -> [PathTo] -> [(Float, Actor, Impulse, Text, Maybe PathTo)]) -- ^ if there is no historic goal, these will be used
+         -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)
+seekGoal memPrefix world actor paths scorePaths = do
+  let keyGoal = memPrefix <> ".goal"
+  let keyAvoid = memPrefix <> ".avoid"
+  let ttlGoal = 50
+  let ttlAvoid = 200
+
+  -- is there already a goal, i.e. already a position the actor is heading towards
+  case mapHeadMay $ M.recall keyGoal (actor ^. acPosMemory) of
+    -- Already seeking a goal
+    Just (goal, _) -> do
+      telld . UeNote $ "seeking goal: " <> show goal
+      
+      --At the goal
+      if goal == actor ^.acWorldPos
+        then do
+          telld . UeNote $ "at goal"
+
+          --Forget the goal and try for next
+          let actor' = actor & acPosMemory %~ M.remember const keyAvoid ttlAvoid goal
+                             & acPosMemory %~ M.forgetAll keyGoal
+
+          let world' = world & wdActors %~ Map.insert (actor ^. acId) actor'
+          seekGoal memPrefix world' actor' (removePathsToAvoid keyAvoid actor' paths) scorePaths
+        else do
+          telld . UeNote $ "not at goal"
+
+          -- Not at the goal, continue towards it
+          -- Only consider paths to the goal
+          let pathsToGoal' = filter (\p -> lastMay (pathPs . path $ p) == Just goal) paths 
+          let pathsToGoal = removePathsToAvoid keyAvoid actor pathsToGoal' 
+
+          selectTopUtility (scorePaths actor pathsToGoal) >>= \case
+            Nothing -> seekGoal memPrefix world (actor & acPosMemory %~ M.forgetAll keyGoal) paths scorePaths
+
+            Just (score', actor', impulse', name', pathToMay') -> do
+              -- if moving to the goal
+              let actorFinal = 
+                    if Just goal == ((flip atMay 1 . pathPs . path) =<< pathToMay')
+                    then
+                      actor' & acPosMemory %~ M.remember const keyAvoid ttlAvoid goal
+                             & acPosMemory %~ M.forgetAll keyGoal
+                    else
+                      actor'
+              
+              -- seek
+              pure ([(score', actorFinal, impulse', name', pathToMay')], world)
+    
+    -- Not seeking a goal
+    Nothing -> do
+      telld . UeNote $ "not seeking goal"
+
+      -- Score all the paths
+      let newGoals = scorePaths actor $ removePathsToAvoid keyAvoid actor paths 
+      -- Select the top scoring one
+      selectTopUtility newGoals >>= \case
+        Nothing -> pure ([], world) -- Nothing to find apparently
+
+        Just (score', actor', impulse', name', pathToMay') ->
+
+          -- The top scoring utility = our new goal
+          case (pathToMay', (lastMay . pathPs . path) =<< pathToMay') of
+            -- Path to the goal and the goal position
+            (Just pathTo, Just goalPos) -> do
+              let newActor = actor' & acPosMemory %~ M.remember const keyGoal ttlGoal goalPos . M.forgetAll keyGoal 
+              pure ([(score', newActor, impulse', name', Just pathTo)], world)
+
+            -- Nothing to find apparently
+            _ -> pure ([], world)
+
+  where
+    mapHeadMay = headMay . Map.toList
+
+    removePathsToAvoid :: Text -> Actor -> [PathTo] -> [PathTo]
+    removePathsToAvoid keyAvoid a scored =
+      let avoid = M.recall keyAvoid $ a ^. acPosMemory in
+      let isInAvoid p = Map.member p avoid in
+      let shouldInclude p = maybe True (not . isInAvoid) (lastMay p) in
+      filter (\p -> shouldInclude (pathPs . path $ p)) scored
+
+
 moveTowardsUtil :: [E.EntityType] -> (Float -> Float) -> [PathTo] -> Actor -> [(PathTo, Float)]
 moveTowardsUtil es rule paths actor =
   let
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/test/GameSpec.hs ./test/GameSpec.hs
--- ../14_utility_annotate/test/GameSpec.hs	1970-01-01 02:00:00.000000000 +0200
+++ ./test/GameSpec.hs	2018-03-04 09:05:24.708261209 +0200
@@ -0,0 +1,108 @@
+{-# LANGUAGE NoImplicitPrelude #-}
+{-# LANGUAGE OverloadedStrings #-}
+
+module GameSpec where
+
+import Protolude 
+import qualified Data.Map.Strict as Map
+import           Test.Hspec
+import           Test.QuickCheck
+
+import           GameCore
+import qualified EntityType as E
+import qualified GameEngine as GE
+
+mkEntityAndTile :: Int -> Text -> (Int, Int) -> (Entity, Tile)
+mkEntityAndTile id name pic =
+  let t = Tile { _tlId = id, _tlName = name, _tlPic = pic } in
+  let a = Entity { _enType = E.Blank, _enTile = t, _enProps = Map.empty, _enAttribs = Map.empty} in
+  (a, t)
+    
+
+tileBlank  :: Tile
+tileWall   :: Tile
+tilePlayer :: Tile
+
+entityBlank  :: Entity
+entityWall   :: Entity
+entityPlayer :: Entity
+
+(entityBlank , tileBlank ) = mkEntityAndTile 1 "blank"  (1, 1) 
+(entityWall  , tileWall  ) = mkEntityAndTile 2 "wall"   (2, 2)
+(entityPlayer, tilePlayer) = mkEntityAndTile 3 "player" (3, 3)
+
+csvSmall :: Text
+csvSmall = " , , ,+, \n\
+           \ , , , , \n\
+           \ ,+, , ,+\n\
+           \ , , , , \n\
+           \ , , ,+, "
+
+spec :: Spec
+spec = do
+  describe "co-ords basics" $ do
+    it "world to player: on (0,0) - 1" $
+      GE.worldCoordToPlayer (WorldPos (0, 0)) (WorldPos (0, 0)) `shouldBe` PlayerPos (0, 0)
+    it "world to player: on (0,0) - 2" $
+      GE.worldCoordToPlayer (WorldPos (0, 0)) (WorldPos (1, 0)) `shouldBe` PlayerPos (1, 0)
+    it "world to player: on (0,0) - 3" $
+      GE.worldCoordToPlayer (WorldPos (0, 0)) (WorldPos (4, 0)) `shouldBe` PlayerPos (4, 0)
+    it "world to player: on (0,0) - 4" $
+      GE.worldCoordToPlayer (WorldPos (0, 0)) (WorldPos (0, 1)) `shouldBe` PlayerPos (0, -1)
+    it "world to player: on (0,0) - 5" $
+      GE.worldCoordToPlayer (WorldPos (0, 0)) (WorldPos (0, 4)) `shouldBe` PlayerPos (0, -4)
+
+    it "world to player: not (0,0) - 1" $
+      GE.worldCoordToPlayer (WorldPos (2, -4)) (WorldPos (2, -4)) `shouldBe` PlayerPos (0, 0)
+    it "world to player: not (0,0) - 2" $
+      GE.worldCoordToPlayer (WorldPos (2, -4)) (WorldPos (6, -7)) `shouldBe` PlayerPos (4, 3)
+
+
+    it "player to world: on (0,0) - 1" $
+      GE.playerCoordToWorld (WorldPos (0, 0)) (PlayerPos (0, 0)) `shouldBe` WorldPos (0, 0)
+    it "player to world: on (0,0) - 2" $
+      GE.playerCoordToWorld (WorldPos (0, 0)) (PlayerPos (1, 0)) `shouldBe` WorldPos (1, 0)
+    it "player to world: on (0,0) - 3" $
+      GE.playerCoordToWorld (WorldPos (0, 0)) (PlayerPos (4, 0)) `shouldBe` WorldPos (4, 0)
+    it "player to world: on (0,0) - 4" $
+      GE.playerCoordToWorld (WorldPos (0, 0)) (PlayerPos (0, -1)) `shouldBe` WorldPos (0, 1)
+    it "player to world: on (0,0) - 5" $
+      GE.playerCoordToWorld (WorldPos (0, 0)) (PlayerPos (0, -4)) `shouldBe` WorldPos (0, 4)
+
+    it "player to world: not (0,0) - 1" $
+      GE.playerCoordToWorld (WorldPos (2, -4)) (PlayerPos (0, 0)) `shouldBe` WorldPos (2, -4)
+    it "player to world: not (0,0) - 2" $
+      GE.playerCoordToWorld (WorldPos (2, -4)) (PlayerPos (4, 3)) `shouldBe` WorldPos (6, -7)
+
+    it "player to world to player" $ property $
+      \x y tx ty -> do
+        let (WorldPos (wx, wy)) = GE.playerCoordToWorld (WorldPos (tx, ty)) (PlayerPos (x, y))
+        let (PlayerPos (px, py)) = GE.worldCoordToPlayer (WorldPos (tx, ty)) (WorldPos (wx, wy))
+        (px, py) `shouldBe` (x, y)
+
+    it "world to player to world" $ property $
+      \x y tx ty -> do
+        let (PlayerPos (px, py)) = GE.worldCoordToPlayer (WorldPos (tx, ty)) (WorldPos (x, y))
+        let (WorldPos (wx, wy)) = GE.playerCoordToWorld (WorldPos (tx, ty)) ( PlayerPos(px, py))
+        (wx, wy) `shouldBe` (x, y)
+
+
+  describe "parse world co-ords" $ do
+    let parsed = GE.parseWorld (Map.fromList [("+", entityWall)]) csvSmall
+
+    it "parsed to player pos" $ do
+      let p = Map.toList parsed
+      p `shouldMatchList` [ (PlayerPos (3, 0), entityWall)
+                          , (PlayerPos (1, 2), entityWall)
+                          , (PlayerPos (4, 2), entityWall)
+                          , (PlayerPos (3, 4), entityWall)
+                          ]
+
+    it "translatePlayerMap to (0, 0)" $ do
+      let wm = GE.translatePlayerMap (WorldPos (0, 0)) parsed
+      let p = Map.toList wm
+      p `shouldMatchList` [ (WorldPos (3,  0), entityWall)
+                          , (WorldPos (1, -2), entityWall)
+                          , (WorldPos (4, -2), entityWall)
+                          , (WorldPos (3, -4), entityWall)
+                          ]
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/test/MemorySpec.hs ./test/MemorySpec.hs
--- ../14_utility_annotate/test/MemorySpec.hs	1970-01-01 02:00:00.000000000 +0200
+++ ./test/MemorySpec.hs	2018-03-04 09:07:50.238815190 +0200
@@ -0,0 +1,110 @@
+{-# OPTIONS_GHC -fno-warn-type-defaults #-}
+{-# LANGUAGE NoImplicitPrelude #-}
+{-# LANGUAGE OverloadedStrings #-}
+
+module MemorySpec where
+
+import Protolude 
+import qualified Data.Map as Map
+import           Test.Hspec
+
+import qualified Memory as M
+
+spec :: Spec
+spec = do
+  describe "simple" $ do
+    it "nothing to recall" $ do
+      let m = M.empty
+      M.remembers "test" 0 m `shouldBe` False
+
+    it "remembers" $ do
+      let m = M.remember (\_ n -> n) "test" 1 (99::Int) M.empty
+      M.remembers "test" 99 m `shouldBe` True
+
+    it "forgets all" $ do
+      let m = M.forgetAll "test" $ M.remember (\_ n -> n) "test" 1 (99::Int) M.empty
+      M.remembers "test" 99 m `shouldBe` False
+
+    it "forgets " $ do
+      let m = M.forget "test" 99 $ M.remember (\_ n -> n) "test" 1 (99::Int) M.empty
+      M.remembers "test" 99 m `shouldBe` False
+
+    it "does not remember, wrong key" $ do
+      let m = M.remember (\_ n -> n) "test" 1 "val99" M.empty
+      M.remembers "!test" "val99" m `shouldBe` False
+
+    it "does not remember, wrong value" $ do
+      let m = M.remember (\_ n -> n) "test" 1 "val99" M.empty
+      M.remembers "test" "val199" m `shouldBe` False
+
+    it "tick removes" $ do
+      let m = M.remember (\_ n -> n) "test" 1 "val99" M.empty
+      M.remembers "test" "val99" (M.tick m) `shouldBe` False
+
+  describe "multi" $ do
+    let orig = [ ("k1", [("k1.a" :: Text, 2), ("k1.b", 3)])
+               , ("k2", [("k2.a", 3)])
+               ]
+
+    let m = M.fromList orig
+
+    it "toList" $ 
+      M.toList m `shouldBe` orig
+    
+    it "remembers" $ do
+      M.remembers "k1" "k1.a" m `shouldBe` True
+      M.remembers "k1" "k1.b" m `shouldBe` True
+      M.remembers "k2" "k2.a" m `shouldBe` True
+
+      M.remembers "k2" "k1.a" m `shouldBe` False
+      M.remembers "k2" "k1.b" m `shouldBe` False
+      M.remembers "k1" "k2.a" m `shouldBe` False
+
+    it "recall" $ do
+      M.recall "k1" m `shouldBe` Map.fromList [("k1.a", 2), ("k1.b", 3)]
+      M.recall "k2" m `shouldBe` Map.fromList [("k2.a", 3)]
+      M.recall "k3" m `shouldBe` Map.empty
+
+    it "tick" $ do
+      let m1 = M.tick m
+      M.recall "k1" m1 `shouldBe` Map.fromList [("k1.a", 1), ("k1.b", 2)]
+      M.recall "k2" m1 `shouldBe` Map.fromList [("k2.a", 2)]
+      M.recall "k3" m1 `shouldBe` Map.empty
+
+      let m2 = M.tick m1
+      M.recall "k1" m2 `shouldBe` Map.fromList [("k1.b", 1)]
+      M.recall "k2" m2 `shouldBe` Map.fromList [("k2.a", 1)]
+      M.recall "k3" m2 `shouldBe` Map.empty
+
+      let m3 = M.tick m2
+      M.recall "k1" m3 `shouldBe` Map.empty
+      M.recall "k2" m3 `shouldBe` Map.empty
+      M.recall "k3" m3 `shouldBe` Map.empty
+
+  describe "combine fn" $ do
+    it "add" $ do
+      let m1 = M.remember (+) "bucket1" 2 "val1" M.empty
+      let m2 = M.remember (+) "bucket1" 3 "val1" m1
+      M.recall "bucket1" m2 `shouldBe` Map.singleton "val1" 5
+
+    it "don't replace" $ do
+      let m1 = M.remember (\_ old -> old) "bucket1" 2 "val1" M.empty
+      let m2 = M.remember (\_ old -> old) "bucket1" 3 "val1" m1
+      M.recall "bucket1" m2 `shouldBe` Map.singleton "val1" 2
+
+    it "replace" $ do
+      let m1 = M.remember const "bucket1" 2 "val1" M.empty
+      let m2 = M.remember const "bucket1" 3 "val1" m1
+      M.recall "bucket1" m2 `shouldBe` Map.singleton "val1" 3
+
+    it "min" $ do
+      let m1 = M.remember min "bucket1" 2 "val1" M.empty
+      let m2 = M.remember min "bucket1" 3 "val1" m1
+      M.recall "bucket1" m2 `shouldBe` Map.singleton "val1" 2
+
+    it "max" $ do
+      let m1 = M.remember max "bucket1" 2 "val1" M.empty
+      let m2 = M.remember max "bucket1" 3 "val1" m1
+      M.recall "bucket1" m2 `shouldBe` Map.singleton "val1" 3
+
+
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/test/Spec.hs ./test/Spec.hs
--- ../14_utility_annotate/test/Spec.hs	1970-01-01 02:00:00.000000000 +0200
+++ ./test/Spec.hs	2018-03-04 09:05:53.155915854 +0200
@@ -0,0 +1,3 @@
+{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
+{-# LANGUAGE NoImplicitPrelude #-}
+
