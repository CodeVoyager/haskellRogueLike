Common subdirectories: ../14_utility_annotate/src/Data and ./src/Data
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/src/GameCore.hs ./src/GameCore.hs
--- ../14_utility_annotate/src/GameCore.hs	2018-03-04 08:48:45.604622557 +0200
+++ ./src/GameCore.hs	2018-03-04 08:48:25.416881367 +0200
@@ -44,6 +44,8 @@
                    --    Note that the world is threaded through the utilities and can be updated (i.e. in the ([], World) result)
                    --    The array of results has an updated actor and a score. These are speculative, and are only applied
                    --    if that utility is selected. The world updates are kept even if nothing is selected
+                   --    This is required because a utility may add a memory even if it can't move and that memory must be kept
+                   --    until its TTL expires
                    , _acUtilities :: ![World -> Actor -> [PathTo] -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)]
                    
                    -- | The actor's disposition - the values that define the actors personality
diff -w -B -a -d -u -b --new-file ../14_utility_annotate/src/Memory.hs ./src/Memory.hs
--- ../14_utility_annotate/src/Memory.hs	1970-01-01 02:00:00.000000000 +0200
+++ ./src/Memory.hs	2018-03-04 08:58:27.497352295 +0200
@@ -0,0 +1,79 @@
+{-# LANGUAGE NoImplicitPrelude #-}
+
+module Memory ( Memory
+              , empty
+              , remember
+              , recall
+              , forget
+              , forgetAll
+              , remembers
+              , tick
+              , toList
+              , fromList
+              ) where
+
+import Protolude hiding (Map, empty, toList)
+import qualified Data.Map.Strict as Map
+import           Data.Map.Strict (Map)
+
+-- | Store (remembers) values for a given period (measured by ticks)
+newtype Memory a = Memory (Map Text (Map a Int)) 
+
+
+empty :: Memory a
+empty = Memory Map.empty
+
+
+remember :: (Ord a) => (Int -> Int -> Int) -> Text -> Int -> a -> Memory a -> Memory a
+remember combineFn key ttl val (Memory m) =
+  Memory $ Map.alter ins key m
+
+  where
+    ins Nothing = Just $ Map.singleton val ttl
+    ins (Just vs) = Just $ Map.insertWith combineFn val ttl vs
+
+
+recall :: Text -> Memory a -> Map a Int
+recall key (Memory m) =
+  fromMaybe Map.empty $ Map.lookup key m 
+
+
+forgetAll :: Text -> Memory a -> Memory a
+forgetAll key (Memory m) =
+  Memory $ Map.delete key m
+
+
+forget :: (Ord a) => Text -> a -> Memory a -> Memory a
+forget key val (Memory m) =
+  Memory $ Map.alter rm key m
+
+  where
+    rm Nothing = Nothing
+    rm (Just vs) = Just $ Map.delete val vs
+
+
+remembers :: (Ord a) => Text -> a -> Memory a -> Bool
+remembers key val m =
+  Map.member val (recall key m)
+
+
+tick :: (Ord a) => Memory a -> Memory a
+tick (Memory m) =
+  Memory $ tickBucket <$> m
+  
+  where
+    tickBucket :: (Ord a) => Map a Int -> Map a Int
+    tickBucket vs =
+      foldr (Map.alter tickVal) vs (Map.keys vs)
+
+    tickVal :: Maybe Int -> Maybe Int
+    tickVal Nothing = Nothing
+    tickVal (Just i) = if i - 1 <= 0 then Nothing else Just (i - 1)
+    
+
+toList :: Memory a -> [(Text, [(a, Int)])]
+toList (Memory m) = Map.toList $ Map.toList <$> m
+
+
+fromList :: (Ord a) => [(Text, [(a, Int)])] -> Memory a
+fromList vs = Memory . Map.fromList $ Map.fromList <<$>> vs
