Common subdirectories: 06_moving/src/Data and 07_collisions/src/Data
diff -w -B -a -d -u -b --new-file 06_moving/src/GameCore.hs 07_collisions/src/GameCore.hs
--- 06_moving/src/GameCore.hs	2018-03-05 14:23:29.951128093 +0200
+++ 07_collisions/src/GameCore.hs	2018-03-05 14:23:29.967127957 +0200
@@ -42,7 +42,8 @@
                    , _wdActors :: !(Map Aid Actor)
                    }
 
-newtype Config = Config { _cfgKeys :: Map Text Text
+data Config = Config { _cfgKeys :: !(Map Text Text)
+                     , _cfgMinMaxBounds :: !(Int, Int, Int, Int) -- (minX, maxX, minY, maxY)
                         }
 
 
diff -w -B -a -d -u -b --new-file 06_moving/src/GameEngine.hs 07_collisions/src/GameEngine.hs
--- 06_moving/src/GameEngine.hs	2018-03-05 14:23:29.951128093 +0200
+++ 07_collisions/src/GameEngine.hs	2018-03-05 14:23:29.967127957 +0200
@@ -15,7 +15,7 @@
 import qualified Data.ByteString.Lazy as BSL
 import qualified Codec.Compression.BZip as Bz
 import qualified System.Random as Rnd
-import           Control.Lens (_1, (^.), (.~), (%~))
+import           Control.Lens (at, _1, (^.), (.~), (%~))
 import qualified Control.Arrow as Ar
 import           Control.Concurrent.STM (atomically, readTVar, newTVar, modifyTVar', TVar)
 
@@ -110,6 +110,7 @@
                                        , ("b"       , "Move:down-left")
                                        , ("pagedown", "Move:down-right")
                                        ]
+             , _cfgMinMaxBounds = (0, 30, -30, 0)
              }
 
     mkPlayer =
@@ -325,5 +326,50 @@
 runAction :: World -> RogueAction -> World
 runAction world action =
   case action of
-    ActMovePlayer (dx, dy) ->
-      world & (wdPlayer . plActor . acWorldPos) %~ (\(WorldPos (x, y)) -> WorldPos (x + dx, y + dy))
+    ActMovePlayer move  ->
+      fromMaybe world $ tryMoveActor world (world ^. wdPlayer ^. plActor) move
+
+
+tryMoveActor :: World -> Actor -> (Int, Int) -> Maybe World
+tryMoveActor world actor (dx, dy) =
+  -- Get the world bounds
+  let (minX, maxX, minY, maxY) = world ^. wdConfig ^. cfgMinMaxBounds in
+
+  -- Actor's position
+  let (WorldPos wdPos) = actor ^. acWorldPos in
+
+  -- Where the actor whats to move to, using bimap :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
+  let tryWorldTo@(tx, ty) = bimap (+ dx) (+ dy) wdPos in
+  let tryWorldTo' = WorldPos tryWorldTo in
+
+  -- Is the actor trying to move out of the world?
+  if tx < minX || ty < minY || tx >= maxX || ty >= maxY
+  then Nothing
+  else
+    let
+      -- Entity at destination
+      destEntity = (world ^. wdMap ^.at tryWorldTo') 
+      destEntityType = _enType <$> destEntity
+      -- Actors at destination
+      destActors = filter (\a -> a ^. acWorldPos == tryWorldTo') (getAllActors world)
+      -- Is the move allowed
+      canMove = case (destActors, destEntityType) of
+                  ([], Just E.Blank) -> True
+                  ([], Just E.Door) -> True
+                  ([], Nothing) -> True
+                  _ -> False
+      in
+      if canMove
+      then
+        let movedActor = actor & acWorldPos .~ tryWorldTo' in
+        Just $ updateActor world movedActor
+      else
+        Nothing
+
+
+-- | Update either the player's actor, or one of the world actors
+updateActor :: World -> Actor -> World
+updateActor w actor =
+  if w ^. wdPlayer ^. plActor ^. acId == (actor ^. acId)
+  then w & (wdPlayer . plActor) .~ actor                         -- update the player's actor
+  else w & wdActors %~ Map.adjust (const actor) (actor ^. acId)  -- update other actor, nop if aid not found
