Common subdirectories: ../04_load_map/src/Data and ./src/Data
diff -w -B -a -d -u -b ../04_load_map/src/Entities.hs ./src/Entities.hs
--- ../04_load_map/src/Entities.hs	2018-02-17 21:16:24.587156744 +0200
+++ ./src/Entities.hs	2018-02-18 17:40:16.896494513 +0200
@@ -19,6 +19,9 @@
            , (E.Door      , (26, 15), Just "+")
            , (E.DoorClosed, (21, 15), Just "-")
            , (E.Wall      , ( 9, 14), Just "w")
+           , (E.Player    , ( 8,  3), Nothing)
+           , (E.Bug       , (25,  3), Nothing)
+           , (E.Snake     , (38,  4), Nothing)
            ]
   in
   let mkData (typ, pos@(x, y), l) (tiles', entities', loads') =
diff -w -B -a -d -u -b ../04_load_map/src/EntityType.hs ./src/EntityType.hs
--- ../04_load_map/src/EntityType.hs	2018-02-17 21:16:24.587156744 +0200
+++ ./src/EntityType.hs	2018-02-18 17:39:23.772976247 +0200
@@ -8,5 +8,8 @@
                 | Door
                 | DoorClosed
                 | Wall
+                | Player
+                | Bug
+                | Snake
                 | Unknown
                 deriving (Show, Eq, Ord)
diff -w -B -a -d -u -b ../04_load_map/src/GameCore.hs ./src/GameCore.hs
--- ../04_load_map/src/GameCore.hs	2018-02-18 15:37:27.344925222 +0200
+++ ./src/GameCore.hs	2018-02-18 17:43:02.267103014 +0200
@@ -11,12 +11,27 @@
 import qualified Data.Text as Txt
 import           Data.Map.Strict (Map)
 import qualified Data.Aeson as Ae
+import qualified System.Random as Rnd
 import           Control.Lens.TH (makeLenses)
 
 import qualified GameHost as Host
 import qualified EntityType as E
 
+data ActorClass = ClassPlayer
+                | ClassEnemy
+                deriving (Show, Eq)
+
+newtype Aid = Aid Text deriving (Show, Eq, Ord)
+
+data Actor = Actor { _acId :: !Aid
+                   , _acClass :: !ActorClass
+                   , _acEntity :: !Entity
+                   , _acWorldPos :: !WorldPos
+                   , _acStdGen :: !Rnd.StdGen
+                   }
+
 data Player = Player { _plConn :: !Host.Connection
+                     , _plActor :: !Actor
                      , _plScreenSize :: !(Int, Int)
                      , _plWorldTopLeft :: !WorldPos
                      }
@@ -24,6 +39,7 @@
 data World = World { _wdPlayer :: !Player
                    , _wdConfig :: !Config
                    , _wdMap :: !(Map WorldPos Entity)
+                   , _wdActors :: !(Map Aid Actor)
                    }
 
 newtype Config = Config { _cfgKeys :: Map Text Text
@@ -50,6 +66,7 @@
 makeLenses ''Player
 makeLenses ''Entity
 makeLenses ''Tile
+makeLenses ''Actor
 
 
 data UiMessage = UiMessage { umCmd :: !Text
diff -w -B -a -d -u -b ../04_load_map/src/GameEngine.hs ./src/GameEngine.hs
--- ../04_load_map/src/GameEngine.hs	2018-02-24 10:02:28.797793166 +0200
+++ ./src/GameEngine.hs	2018-02-18 17:54:50.574217847 +0200
@@ -14,6 +14,7 @@
 import qualified Data.Aeson.Text.Extended as Ae
 import qualified Data.ByteString.Lazy as BSL
 import qualified Codec.Compression.BZip as Bz
+import qualified System.Random as Rnd
 import           Control.Lens (_1, (^.), (.~), (%~))
 import qualified Control.Arrow as Ar
 import           Control.Concurrent.STM (atomically, readTVar, newTVar, modifyTVar', TVar)
@@ -36,8 +37,9 @@
   case parseCommand initCmd of
     Just ("init", cmdData) -> do
       mapData <- Txt.readFile "worlds/simple.csv"
+      std <- Rnd.getStdGen
       
-      case initialiseConnection conn cmdData mapData of
+      case initialiseConnection conn cmdData mapData std of
         Right world -> do
           worldV <- atomically $ newTVar world
           sendConfig conn $ world ^. wdConfig
@@ -64,23 +66,30 @@
         _ -> Nothing
       
 
-initialiseConnection :: Host.Connection -> [Text] -> Text -> Either Text World
-initialiseConnection conn cmdData mapData = 
+initialiseConnection :: Host.Connection -> [Text] -> Text -> Rnd.StdGen -> Either Text World
+initialiseConnection conn cmdData mapData std = 
   case parseScreenSize cmdData of
     Nothing ->
       Left "missing / invalid screen size"
 
     Just (width, height) ->
-      Right $ bootWorld conn (width, height) mapData
+      Right $ bootWorld conn (width, height) mapData std
 
 
-bootWorld :: Host.Connection -> (Int, Int) -> Text -> World
-bootWorld conn screenSize mapData = 
-  let config = mkConfig in
+bootWorld :: Host.Connection -> (Int, Int) -> Text -> Rnd.StdGen -> World
+bootWorld conn screenSize mapData std = 
+  let
+    config = mkConfig
+    bug = mkEnemyActor "bug1" E.Bug (6, -2)
+    snake = mkEnemyActor "snake1" E.Snake (8, -4)
+  in
    
   World { _wdPlayer = mkPlayer
         , _wdConfig = config
         , _wdMap = loadWorld E.loadTexts mapData
+        , _wdActors = Map.fromList [ (bug ^. acId, bug)
+                                   , (snake ^. acId, snake)
+                                   ]
         }
   where
     mkConfig =
@@ -90,6 +99,23 @@
       Player { _plConn = conn
              , _plScreenSize = screenSize
              , _plWorldTopLeft = WorldPos (0, 0)
+             , _plActor = mkPlayersActor
+             }
+
+    mkPlayersActor =
+      Actor { _acId = Aid "player"
+            , _acClass = ClassPlayer
+            , _acEntity = E.getEntity E.Player
+            , _acWorldPos = WorldPos (1, -1)
+            , _acStdGen = std
+            }
+
+    mkEnemyActor aid e (x, y) =
+      Actor { _acId = Aid aid
+            , _acClass = ClassEnemy
+            , _acEntity = E.getEntity e
+            , _acWorldPos = WorldPos (x, y)
+            , _acStdGen = std
              }
     
 
@@ -224,8 +250,19 @@
       -- Filter out blank
     noEmptyMap = Map.filter (\e -> e ^. enTile ^. tlName /= "blank") entityMap
 
+    -- Add the actors to the map.
+    -- Notice that this will replace whatever entity was there (for this draw)
+    -- This fold works by
+    --    - Starting with the map of entities that are not blank
+    --    - Inserting each actor into the updated map (the accumulator)
+    -- getAllActors is called to get the player's actor and all other actors
+    noEmptyMapWithActors = foldr
+                           (\actor accum -> Map.insert (actor ^. acWorldPos) (actor ^. acEntity) accum)
+                           noEmptyMap
+                           (getAllActors world)
+
     -- Only get the entitys that are at positions on the player's screen
-    visibleEntitys = Map.filterWithKey (inView topX topY bottomX bottomY) noEmptyMap
+    visibleEntitys = Map.filterWithKey (inView topX topY bottomX bottomY) noEmptyMapWithActors
 
     -- Get the tile for each entity
     tileMap = (^. enTile) <$> visibleEntitys
@@ -236,3 +273,8 @@
   where
     inView topX topY bottomX bottomY (WorldPos (x, y)) _ =
       x >= topX && x < bottomX && y > bottomY && y <= topY
+
+
+getAllActors :: World -> [Actor]
+getAllActors world =
+  world ^. wdPlayer ^. plActor : Map.elems (world ^. wdActors)
