Common subdirectories: 14_utility_annotate/src/Data and 15_memory/src/Data
diff -w -B -a -d -u -b --new-file 14_utility_annotate/src/GameCore.hs 15_memory/src/GameCore.hs
--- 14_utility_annotate/src/GameCore.hs	2018-03-05 12:11:01.269072320 +0200
+++ 15_memory/src/GameCore.hs	2018-03-05 12:11:01.273072245 +0200
@@ -17,6 +17,7 @@
 import           Control.Lens.TH (makeLenses)
 import           Control.Monad.Writer.Strict (Writer)
 
+import qualified Memory as M
 import qualified GameHost as Host
 import qualified EntityType as E
 import qualified BoundedInt as B
@@ -44,10 +45,15 @@
                    --    Note that the world is threaded through the utilities and can be updated (i.e. in the ([], World) result)
                    --    The array of results has an updated actor and a score. These are speculative, and are only applied
                    --    if that utility is selected. The world updates are kept even if nothing is selected
+                   --    This is required because a utility may add a memory even if it can't move and that memory must be kept
+                   --    until its TTL expires
                    , _acUtilities :: ![World -> Actor -> [PathTo] -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)]
                    
                    -- | The actor's disposition - the values that define the actors personality
                    , _acDisposition :: !Disposition
+
+                   -- | The actor's memory about positions
+                   , _acPosMemory :: !(M.Memory WorldPos)
                    }
 
 data Player = Player { _plConn :: !Host.Connection
diff -w -B -a -d -u -b --new-file 14_utility_annotate/src/GameEngine.hs 15_memory/src/GameEngine.hs
--- 14_utility_annotate/src/GameEngine.hs	2018-03-05 12:11:01.273072245 +0200
+++ 15_memory/src/GameEngine.hs	2018-03-05 12:11:01.277072171 +0200
@@ -24,6 +24,7 @@
 import           Control.Monad.Writer.Strict (runWriter)
 import           Control.Concurrent.STM (atomically, readTVar, newTVar, modifyTVar', TVar)
 
+import qualified Memory as M
 import           GameCore
 import qualified GameHost as Host
 import           GameHost (conSendData, conReceiveText)
@@ -166,6 +167,7 @@
             , _acEnergy = B.new 200 100
             , _acUtilities = []
             , _acDisposition = UB.emptyDisposition
+            , _acPosMemory = M.empty
             }
 
     mkEnemyActor aid e (x, y) =
@@ -182,6 +184,7 @@
             , _acEnergy = B.new 180 100
             , _acUtilities = []
             , _acDisposition = UB.emptyDisposition 
+            , _acPosMemory = M.empty
             }
     
 
@@ -732,6 +735,7 @@
           >>= checkIfNonMove
           >>= checkIfPlayerHasMinEnergy
           >>= runPendingIfPlayerHasEnergy
+          >>= runPlayerTick -- run the tick for the player, this is only run if the move was allowed
           >>= stopIfPlayerCanStillMove
   in
   case playerAttemptedMoveWorld of
@@ -765,6 +769,9 @@
         -- disallow
         Left w
 
+    runPlayerTick w =
+      Right $ w & (wdPlayer . plActor) %~ actorTick
+
     stopIfPlayerCanStillMove w =
       let
         a = w ^. wdPlayer ^. plActor 
@@ -935,3 +942,8 @@
     (\a g -> Map.insert (a ^. acWorldPos) (a ^. acEntity) g)
     (w ^. wdMap)
     (getAllActors w)
+
+  
+actorTick :: Actor -> Actor
+actorTick a =
+  a & acPosMemory %~ M.tick
diff -w -B -a -d -u -b --new-file 14_utility_annotate/src/Memory.hs 15_memory/src/Memory.hs
--- 14_utility_annotate/src/Memory.hs	1970-01-01 02:00:00.000000000 +0200
+++ 15_memory/src/Memory.hs	2018-03-05 12:11:01.273072245 +0200
@@ -0,0 +1,79 @@
+{-# LANGUAGE NoImplicitPrelude #-}
+
+module Memory ( Memory
+              , empty
+              , remember
+              , recall
+              , forget
+              , forgetAll
+              , remembers
+              , tick
+              , toList
+              , fromList
+              ) where
+
+import Protolude hiding (Map, empty, toList)
+import qualified Data.Map.Strict as Map
+import           Data.Map.Strict (Map)
+
+-- | Store (remembers) values for a given period (measured by ticks)
+newtype Memory a = Memory (Map Text (Map a Int)) 
+
+
+empty :: Memory a
+empty = Memory Map.empty
+
+
+remember :: (Ord a) => (Int -> Int -> Int) -> Text -> Int -> a -> Memory a -> Memory a
+remember combineFn key ttl val (Memory m) =
+  Memory $ Map.alter ins key m
+
+  where
+    ins Nothing = Just $ Map.singleton val ttl
+    ins (Just vs) = Just $ Map.insertWith combineFn val ttl vs
+
+
+recall :: Text -> Memory a -> Map a Int
+recall key (Memory m) =
+  fromMaybe Map.empty $ Map.lookup key m 
+
+
+forgetAll :: Text -> Memory a -> Memory a
+forgetAll key (Memory m) =
+  Memory $ Map.delete key m
+
+
+forget :: (Ord a) => Text -> a -> Memory a -> Memory a
+forget key val (Memory m) =
+  Memory $ Map.alter rm key m
+
+  where
+    rm Nothing = Nothing
+    rm (Just vs) = Just $ Map.delete val vs
+
+
+remembers :: (Ord a) => Text -> a -> Memory a -> Bool
+remembers key val m =
+  Map.member val (recall key m)
+
+
+tick :: (Ord a) => Memory a -> Memory a
+tick (Memory m) =
+  Memory $ tickBucket <$> m
+  
+  where
+    tickBucket :: (Ord a) => Map a Int -> Map a Int
+    tickBucket vs =
+      foldr (Map.alter tickVal) vs (Map.keys vs)
+
+    tickVal :: Maybe Int -> Maybe Int
+    tickVal Nothing = Nothing
+    tickVal (Just i) = if i - 1 <= 0 then Nothing else Just (i - 1)
+    
+
+toList :: Memory a -> [(Text, [(a, Int)])]
+toList (Memory m) = Map.toList $ Map.toList <$> m
+
+
+fromList :: (Ord a) => [(Text, [(a, Int)])] -> Memory a
+fromList vs = Memory . Map.fromList $ Map.fromList <<$>> vs
diff -w -B -a -d -u -b --new-file 14_utility_annotate/src/UtilityBrain.hs 15_memory/src/UtilityBrain.hs
--- 14_utility_annotate/src/UtilityBrain.hs	2018-03-05 12:11:01.269072320 +0200
+++ 15_memory/src/UtilityBrain.hs	2018-03-05 12:11:01.273072245 +0200
@@ -3,6 +3,7 @@
 {-# LANGUAGE OverloadedStrings #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE LambdaCase #-}
 
 module UtilityBrain ( selectTopUtility
                     , assessUtilities
@@ -13,6 +14,7 @@
                     ) where
 
 import Protolude 
+import qualified Data.Map.Strict as Map
 import qualified Data.List as Lst
 import qualified Data.DList as DLst
 import qualified System.Random as Rnd
@@ -20,6 +22,7 @@
 import           Control.Lens
 import           Control.Monad.Writer.Strict (tell, MonadWriter)
 
+import qualified Memory as M
 import           GameCore
 import qualified EntityType as E
 
@@ -32,6 +35,9 @@
 path (PathToActor p _ _) = p
 path (PathToPlayer p _ _) = p
 
+pathPs :: Path -> [WorldPos]
+pathPs (Path p) = p
+
 selectTopUtility :: [(Float, Actor, Impulse, Text, Maybe PathTo)]
                  -> UtilAnnotator (Maybe (Float, Actor, Impulse, Text, Maybe PathTo))
 selectTopUtility rs = do
@@ -135,12 +141,30 @@
 
 
 utilityOfWanderToExit :: World -> Actor -> [PathTo] -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)
-utilityOfWanderToExit world actor allPaths = do
+utilityOfWanderToExit world actor' allPaths = do
   telld $ UeAt "WanderToExit"
+  telld . UeNote $ "at: " <> show (actor' ^. acWorldPos)
+  telld . UeNote $ "goal: " <> show (M.recall "wanderToExit.goal" $ actor' ^. acPosMemory)
+  telld . UeNote $ "avoid: " <> show (M.recall "wanderToExit.avoid" $ actor' ^. acPosMemory)
 
-  let rule x = clamp $ 1 - (0.04 * x + (1.24 - clamp (actor ^. acDisposition ^. dsWanderlustToExits))) 
-  let clampedResults = moveTowardsUtil [E.Door] rule allPaths actor
-  pure ((\(p, score) -> (score, actor, ImpMoveTowards (path p), "wander to exit", Just p)) <$> clampedResults, world)
+  let rule x = clamp $ 1 - (0.04 * x + (1.24 - clamp (actor' ^. acDisposition ^. dsWanderlustToExits))) 
+
+  -- Find exits
+  let goalPaths = onlyEntitiesOfType [E.Door] allPaths 
+
+  let seek actor paths = do
+        -- Normalise distances
+        let pathsNormalisedMay = (\p -> (p, distanceToRange p (actor ^. acFovDistance))) <$> paths 
+        let pathsNormalised = catNormalisedMay pathsNormalisedMay 
+        -- Run utility calculation
+        let results = Ar.second rule <$> pathsNormalised 
+        let clampedResults = Ar.second clamp <$> results
+        -- Result
+        (\(p, score) -> (score, actor, ImpMoveTowards (path p), "wander to exit", Just p)) <$> clampedResults
+  
+  r <- seekGoal "wanderToExit" world actor' goalPaths seek
+  telld . UeNote $ "res.len= " <> show (length r)
+  pure r
 
   
 utilityOfInfatuation :: World -> Actor -> [PathTo] -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)
@@ -157,6 +181,92 @@
   pure ((\(p, score) -> (score, actor, ImpMoveTowards (path p), "infatuation", Just p)) <$> clampedResults, world)
 
 
+seekGoal :: Text     -- ^ prefix for memory storage
+         -> World
+         -> Actor    -- ^ the moving actor
+         -> [PathTo] -- ^ filtered paths, any one of which is a valid goal
+         -> (Actor -> [PathTo] -> [(Float, Actor, Impulse, Text, Maybe PathTo)]) -- ^ if there is no historic goal, these will be used
+         -> UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)
+seekGoal memPrefix world actor paths scorePaths = do
+  let keyGoal = memPrefix <> ".goal"
+  let keyAvoid = memPrefix <> ".avoid"
+  let ttlGoal = 50
+  let ttlAvoid = 200
+
+  -- is there already a goal, i.e. already a position the actor is heading towards
+  case mapHeadMay $ M.recall keyGoal (actor ^. acPosMemory) of
+    -- Already seeking a goal
+    Just (goal, _) -> do
+      telld . UeNote $ "seeking goal: " <> show goal
+      
+      --At the goal
+      if goal == actor ^.acWorldPos
+        then do
+          telld . UeNote $ "at goal"
+
+          --Forget the goal and try for next
+          let actor' = actor & acPosMemory %~ M.remember const keyAvoid ttlAvoid goal
+                             & acPosMemory %~ M.forgetAll keyGoal
+
+          let world' = world & wdActors %~ Map.insert (actor ^. acId) actor'
+          seekGoal memPrefix world' actor' (removePathsToAvoid keyAvoid actor' paths) scorePaths
+        else do
+          telld . UeNote $ "not at goal"
+
+          -- Not at the goal, continue towards it
+          -- Only consider paths to the goal
+          let pathsToGoal' = filter (\p -> lastMay (pathPs . path $ p) == Just goal) paths 
+          let pathsToGoal = removePathsToAvoid keyAvoid actor pathsToGoal' 
+
+          selectTopUtility (scorePaths actor pathsToGoal) >>= \case
+            Nothing -> seekGoal memPrefix world (actor & acPosMemory %~ M.forgetAll keyGoal) paths scorePaths
+
+            Just (score', actor', impulse', name', pathToMay') -> do
+              -- if moving to the goal
+              let actorFinal = 
+                    if Just goal == ((flip atMay 1 . pathPs . path) =<< pathToMay')
+                    then
+                      actor' & acPosMemory %~ M.remember const keyAvoid ttlAvoid goal
+                             & acPosMemory %~ M.forgetAll keyGoal
+                    else
+                      actor'
+              
+              -- seek
+              pure ([(score', actorFinal, impulse', name', pathToMay')], world)
+    
+    -- Not seeking a goal
+    Nothing -> do
+      telld . UeNote $ "not seeking goal"
+
+      -- Score all the paths
+      let newGoals = scorePaths actor $ removePathsToAvoid keyAvoid actor paths 
+      -- Select the top scoring one
+      selectTopUtility newGoals >>= \case
+        Nothing -> pure ([], world) -- Nothing to find apparently
+
+        Just (score', actor', impulse', name', pathToMay') ->
+
+          -- The top scoring utility = our new goal
+          case (pathToMay', (lastMay . pathPs . path) =<< pathToMay') of
+            -- Path to the goal and the goal position
+            (Just pathTo, Just goalPos) -> do
+              let newActor = actor' & acPosMemory %~ M.remember const keyGoal ttlGoal goalPos . M.forgetAll keyGoal 
+              pure ([(score', newActor, impulse', name', Just pathTo)], world)
+
+            -- Nothing to find apparently
+            _ -> pure ([], world)
+
+  where
+    mapHeadMay = headMay . Map.toList
+
+    removePathsToAvoid :: Text -> Actor -> [PathTo] -> [PathTo]
+    removePathsToAvoid keyAvoid a scored =
+      let avoid = M.recall keyAvoid $ a ^. acPosMemory in
+      let isInAvoid p = Map.member p avoid in
+      let shouldInclude p = maybe True (not . isInAvoid) (lastMay p) in
+      filter (\p -> shouldInclude (pathPs . path $ p)) scored
+
+
 moveTowardsUtil :: [E.EntityType] -> (Float -> Float) -> [PathTo] -> Actor -> [(PathTo, Float)]
 moveTowardsUtil es rule paths actor =
   let
