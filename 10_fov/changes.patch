Common subdirectories: ../09_viewport_scroll/src/Data and ./src/Data
diff -w -B -a -d -u -b ../09_viewport_scroll/src/Entities.hs ./src/Entities.hs
--- ../09_viewport_scroll/src/Entities.hs	2018-02-24 11:08:40.560457089 +0200
+++ ./src/Entities.hs	2018-03-02 19:02:24.432138189 +0200
@@ -22,6 +22,7 @@
            , (E.Player    , ( 8,  3), Nothing)
            , (E.Bug       , (25,  3), Nothing)
            , (E.Snake     , (38,  4), Nothing)
+           , (E.Dark      , (43, 11), Nothing)
            ]
   in
   let mkData (typ, pos@(x, y), l) (tiles', entities', loads') =
diff -w -B -a -d -u -b ../09_viewport_scroll/src/EntityType.hs ./src/EntityType.hs
--- ../09_viewport_scroll/src/EntityType.hs	2018-02-24 11:08:40.560457089 +0200
+++ ./src/EntityType.hs	2018-03-02 19:02:31.400399053 +0200
@@ -11,5 +11,6 @@
                 | Player
                 | Bug
                 | Snake
+                | Dark
                 | Unknown
                 deriving (Show, Eq, Ord)
diff -w -B -a -d -u -b ../09_viewport_scroll/src/GameCore.hs ./src/GameCore.hs
--- ../09_viewport_scroll/src/GameCore.hs	2018-02-24 11:42:08.035901655 +0200
+++ ./src/GameCore.hs	2018-02-27 18:31:55.730545080 +0200
@@ -28,6 +28,8 @@
                    , _acEntity :: !Entity
                    , _acWorldPos :: !WorldPos
                    , _acStdGen :: !Rnd.StdGen
+                   , _acFov :: !(Maybe [(WorldPos, [WorldPos])])
+                   , _acFovDistance :: !Int
                    }
 
 data Player = Player { _plConn :: !Host.Connection
diff -w -B -a -d -u -b ../09_viewport_scroll/src/GameEngine.hs ./src/GameEngine.hs
--- ../09_viewport_scroll/src/GameEngine.hs	2018-03-03 06:47:31.560497471 +0200
+++ ./src/GameEngine.hs	2018-03-03 07:42:52.733297248 +0200
@@ -7,6 +7,7 @@
 import Protolude hiding (Map)
 import           Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
+import qualified Data.List as Lst
 import qualified Data.List.Index as Lst
 import qualified Data.Text as Txt
 import qualified Data.Text.IO as Txt
@@ -82,15 +83,22 @@
     config = mkConfig
     bug = mkEnemyActor "bug1" E.Bug (6, -2)
     snake = mkEnemyActor "snake1" E.Snake (8, -4)
-  in
    
-  World { _wdPlayer = mkPlayer
+    w1 = World { _wdPlayer = mkPlayer
         , _wdConfig = config
         , _wdMap = loadWorld E.loadTexts mapData
         , _wdActors = Map.fromList [ (bug ^. acId, bug)
                                    , (snake ^. acId, snake)
                                    ]
         }
+
+    -- The player's actor
+    pa = w1 ^. wdPlayer ^. plActor 
+  in
+
+  -- Calculate the player actor's fov
+  updateActor w1 $ pa & acFov .~ Just (calcFov (pa ^. acFovDistance) (isTransparent $ w1 ^. wdMap) (pa ^. acWorldPos))
+
   where
     mkConfig =
       Config { _cfgKeys = Map.fromList [ ("up"      , "Move:up")
@@ -133,6 +141,8 @@
             , _acEntity = E.getEntity E.Player
             , _acWorldPos = WorldPos (1, -1)
             , _acStdGen = std
+            , _acFovDistance = 3
+            , _acFov = Nothing
             }
 
     mkEnemyActor aid e (x, y) =
@@ -141,6 +151,8 @@
             , _acEntity = E.getEntity e
             , _acWorldPos = WorldPos (x, y)
             , _acStdGen = std
+            , _acFovDistance = 2
+            , _acFov = Nothing
             }
     
 
@@ -267,14 +279,22 @@
 drawTilesForPlayer world entityMap =
   let
     -- Entity base layer
-    entityLayer = mkLayer entityMap
+    entities = mkLayer entityMap
+    -- Darkness
+    darknessOverlay = darknessFovOverlay (world ^. wdPlayer) (world ^. wdPlayer ^. plActor)
+    -- Darkness hides entity
+    baseLayer = Map.union darknessOverlay entities
 
     -- Actor layer on top
     actorMap = Map.fromList $ (\a -> (a ^. acWorldPos, a ^. acEntity)) <$> getAllActors world
-    visibleActorMap = Map.filterWithKey inView actorMap
-    actorLayer = mkLayer visibleActorMap
+    inViewActors = Map.filterWithKey inView actorMap
+    actorLayer = mkLayer inViewActors
+    visibleActorLayer = Map.filterWithKey (\wp _ -> isNotDarkness wp baseLayer) actorLayer
   in
-    [entityLayer, actorLayer]
+    -- Layers
+    -- 0: Entities (with darkness overlay)
+    -- 1: Actors
+    [baseLayer, visibleActorLayer]
 
   where
     player = world ^. wdPlayer
@@ -288,6 +308,12 @@
     -- | Bottom right corner
     (bottomX, bottomY) = (topX + screenX, topY - screenY) 
 
+    isNotDarkness :: PlayerPos -> Map PlayerPos Tile -> Bool
+    isNotDarkness wp ts =
+      case Map.lookup wp ts of
+        Nothing -> True
+        Just t -> t ^. tlId /= E.getTile E.Dark ^. tlId
+  
     inView (WorldPos (x, y)) _ =
       x >= topX && x < bottomX && y > bottomY && y <= topY
 
@@ -383,11 +409,19 @@
       in
       if canMove
       then
-        let movedActor = actor & acWorldPos .~ tryWorldTo' in
-        Just . updatePlayerViewport $ updateActor world movedActor
+        let
+          movedActor = actor & acWorldPos .~ tryWorldTo'
+          w2 = updatePlayerViewport $ updateActor world movedActor
+          pa = w2 ^. wdPlayer ^. plActor
+        in
+          Just $ updateActor w2 (updateActorFov w2 pa)
       else
         Nothing
 
+  where
+    updateActorFov w a =
+      a & acFov .~ Just (calcFov (a ^. acFovDistance) (isTransparent $ w ^. wdMap) (a ^. acWorldPos))
+
 
 -- | Update either the player's actor, or one of the world actors
 updateActor :: World -> Actor -> World
@@ -459,3 +493,87 @@
                | otherwise -> 0
       in
       (x, y)
+
+
+-- | Calculate the field of view from a position
+calcFov :: Int -> (WorldPos -> Bool) -> WorldPos -> [(WorldPos, [WorldPos])]
+calcFov fovDistance isEntityTransparent fromPos'@(WorldPos fromPos) =
+  let boundries = getBoundries fromPos' in
+  go <$> boundries
+
+  where
+    getBoundries (WorldPos (x, y)) = boundingPoints fovDistance (WorldPos (x, y))
+
+    go toPos'@(WorldPos toPos) =
+      let line = WorldPos <$> bline fromPos toPos in
+      let isTransparentOrStart p = p == fromPos' || isEntityTransparent p in
+      let (m, r) = Lst.span isTransparentOrStart line in
+      (toPos', m <> Lst.take 1 r)
+
+
+-- | Get the bounds for a fov distance
+boundingPoints :: Int -> WorldPos -> [WorldPos]
+boundingPoints distance (WorldPos (atx, aty)) =
+  Lst.nub $
+    [WorldPos (atx - distance + d, aty - distance) | d <- [0..distance * 2]] <>
+    [WorldPos (atx - distance, aty - distance + d) | d <- [0..distance * 2]] <>
+    [WorldPos (atx - distance + d, aty + distance) | d <- [0..distance * 2]] <>
+    [WorldPos (atx + distance, aty - distance + d) | d <- [0..distance * 2]]
+              
+
+-- | Bresenham's algorithm
+-- | https://wiki.haskell.org/Bresenham%27s_line_drawing_algorithm
+bline :: (Int, Int) -> (Int, Int) -> [(Int, Int)]
+bline pa@(xa, ya) pb@(xb, yb) =
+  let r = map maySwitch . Lst.unfoldr go $ (x1, y1, 0) in
+
+  case r of
+    (p:_) | p == pa -> r
+    _ -> Lst.reverse r
+
+  where
+    steep = abs (yb - ya) > abs (xb - xa)
+    maySwitch = if steep then (\(x,y) -> (y,x)) else identity
+    ((x1, y1), (x2, y2)) = case Lst.sort [maySwitch pa, maySwitch pb] of
+                             [a, b] -> (a, b)
+                             _ -> ((0, 0), (0, 0)) -- This case is never matched, but fixes partial match warning
+    deltax = x2 - x1
+    deltay = abs (y2 - y1)
+    ystep = if y1 < y2 then 1 else -1
+    go (xTemp, yTemp, err)
+        | xTemp > x2 = Nothing
+        | otherwise = Just ((xTemp, yTemp), (xTemp + 1, newY, newError))
+        where
+          tempError = err + deltay
+          (newY, newError) = if (2 * tempError) >= deltax
+                            then (yTemp + ystep, tempError - deltax)
+                            else (yTemp, tempError)
+
+  
+isTransparent :: Map WorldPos Entity -> WorldPos -> Bool
+isTransparent wmap pos =
+  case Map.lookup pos wmap of
+    Nothing -> True
+    Just e -> (e ^. enType) /= E.Wall
+
+  
+darknessFovOverlay :: Player -> Actor -> Map PlayerPos Tile
+darknessFovOverlay player actor =
+  let
+    (screenWidth, screenHeight) = player ^. plScreenSize
+
+    -- Create a full grid of darkness
+    blackBg = Map.fromList [ (PlayerPos (x, y), E.getTile E.Dark)
+                           | x <- [0..(screenWidth - 1)]
+                           , y <- [0..(screenHeight - 1)]
+                           ] 
+
+    lightAt = worldCoordToPlayer (player ^. plWorldTopLeft) <$> flatFov (actor ^. acFov)
+  in
+  -- Remove the darkness overlay at any position that is to be lit
+  foldr Map.delete blackBg lightAt
+
+  
+flatFov :: Maybe [(WorldPos, [WorldPos])] -> [WorldPos]
+flatFov Nothing = []
+flatFov (Just fov) = Lst.nub . Lst.concat $ snd <$> fov
