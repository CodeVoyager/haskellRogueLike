Common subdirectories: ../03_tiles/src/Data and ./src/Data
diff -w -B -a -d -u -b ../03_tiles/src/GameCore.hs ./src/GameCore.hs
--- ../03_tiles/src/GameCore.hs	2018-02-18 15:37:39.082266617 +0200
+++ ./src/GameCore.hs	2018-02-18 15:37:27.344925222 +0200
@@ -18,10 +18,12 @@
 
 data Player = Player { _plConn :: !Host.Connection
                      , _plScreenSize :: !(Int, Int)
+                     , _plWorldTopLeft :: !WorldPos
                      }
 
 data World = World { _wdPlayer :: !Player
                    , _wdConfig :: !Config
+                   , _wdMap :: !(Map WorldPos Entity)
                    }
 
 newtype Config = Config { _cfgKeys :: Map Text Text
@@ -38,6 +41,9 @@
                      , _enAttribs :: !(Map Text Int)
                      } deriving (Show, Eq, Ord)
 
+newtype WorldPos = WorldPos (Int, Int) deriving (Show, Eq, Ord)
+newtype PlayerPos = PlayerPos (Int, Int) deriving (Show, Eq, Ord)
+
 
 makeLenses ''World
 makeLenses ''Config
@@ -70,6 +76,7 @@
 data UiDrawCommand = UiDrawCommand
                      { drCmd :: !Text
                      , drScreenWidth :: !Int
+                     , drMapData :: ![(Int, Int, Int)]
                      } deriving (Generic)
 
 
diff -w -B -a -d -u -b ../03_tiles/src/GameEngine.hs ./src/GameEngine.hs
--- ../03_tiles/src/GameEngine.hs	2018-02-18 10:10:17.309202811 +0200
+++ ./src/GameEngine.hs	2018-02-18 17:50:42.447800124 +0200
@@ -5,13 +5,17 @@
 module GameEngine where
 
 import Protolude hiding (Map)
+import           Data.Map.Strict (Map)
 import qualified Data.Map.Strict as Map
+import qualified Data.List.Index as Lst
 import qualified Data.Text as Txt
+import qualified Data.Text.IO as Txt
 import qualified Data.Text.Encoding as TxtE
 import qualified Data.Aeson.Text.Extended as Ae
 import qualified Data.ByteString.Lazy as BSL
 import qualified Codec.Compression.BZip as Bz
 import           Control.Lens (_1, (^.), (.~), (%~))
+import qualified Control.Arrow as Ar
 import           Control.Concurrent.STM (atomically, readTVar, newTVar, modifyTVar', TVar)
 
 import           GameCore
@@ -30,8 +34,10 @@
   initCmd <- conn ^. conReceiveText 
 
   case parseCommand initCmd of
-    Just ("init", cmdData) ->
-      case initialiseConnection conn cmdData of
+    Just ("init", cmdData) -> do
+      mapData <- Txt.readFile "worlds/simple.csv"
+      
+      case initialiseConnection conn cmdData mapData of
          Right world -> do
           worldV <- atomically $ newTVar world
           sendConfig conn $ world ^. wdConfig
@@ -58,27 +64,33 @@
         _ -> Nothing
       
 
-initialiseConnection :: Host.Connection -> [Text] -> Either Text World
-initialiseConnection conn cmdData = 
+initialiseConnection :: Host.Connection -> [Text] -> Text -> Either Text World
+initialiseConnection conn cmdData mapData = 
   case parseScreenSize cmdData of
     Nothing ->
       Left "missing / invalid screen size"
 
     Just (width, height) ->
-      Right $ bootWorld conn (width, height) 
+      Right $ bootWorld conn (width, height) mapData
 
 
-bootWorld :: Host.Connection -> (Int, Int) -> World
-bootWorld conn screenSize = 
+bootWorld :: Host.Connection -> (Int, Int) -> Text -> World
+bootWorld conn screenSize mapData = 
+  let config = mkConfig in
+   
   World { _wdPlayer = mkPlayer
-        , _wdConfig = mkConfig
+        , _wdConfig = config
+        , _wdMap = loadWorld E.loadTexts mapData
         }
   where
     mkConfig =
       Config { _cfgKeys = Map.fromList [("t", "test")] }
 
     mkPlayer =
-      Player conn screenSize
+      Player { _plConn = conn
+             , _plScreenSize = screenSize
+             , _plWorldTopLeft = WorldPos (0, 0)
+             }
     
 
 runCmd :: Host.Connection -> TVar World -> Text -> [Text] -> IO ()
@@ -148,7 +160,79 @@
 
 drawAndSend :: World -> IO ()
 drawAndSend world = do
+  let playerTiles = drawTilesForPlayer world (world ^. wdMap) 
+  
   let cmd = Ae.encodeText UiDrawCommand { drCmd = "draw"
                                         , drScreenWidth = world ^. wdPlayer ^. plScreenSize ^. _1
+                                        , drMapData = mkDrawMapData <$> Map.toList playerTiles
                                         }
   sendData (world ^. wdPlayer ^. plConn) cmd
+
+  where
+    mkDrawMapData :: (PlayerPos, Tile) -> (Int, Int, Int)
+    mkDrawMapData (PlayerPos (x, y), tile) = (x, y, tile ^. tlId)
+
+  
+loadWorld :: Map Text Entity -> Text -> Map WorldPos Entity
+loadWorld chars csv = 
+  translatePlayerMap (WorldPos (0, 0)) $ parseWorld chars csv
+
+
+parseWorld :: Map Text Entity -> Text -> Map PlayerPos Entity
+parseWorld chars csv = 
+  let ls = Txt.lines csv in
+  let lss = Txt.strip <<$>> (Txt.splitOn "," <$> ls) in
+  let entityMap = Lst.imap (\r cs -> Lst.imap (loadCol r) cs) lss in
+  Map.fromList . catMaybes $ concat entityMap
+
+  where
+    loadCol y x c = case Map.lookup c chars of
+                      Nothing -> Nothing
+                      Just a -> Just (PlayerPos (x, y), a)
+
+
+translatePlayerMap :: WorldPos -> Map PlayerPos Entity -> Map WorldPos Entity
+translatePlayerMap worldTopLeft entityMap =
+  let entitysInWorld = Ar.first (playerCoordToWorld worldTopLeft) <$> Map.toList entityMap  in
+  Map.fromList entitysInWorld
+
+
+playerCoordToWorld :: WorldPos -> PlayerPos -> WorldPos
+playerCoordToWorld (WorldPos (worldTopX, worldTopY)) (PlayerPos (playerX, playerY)) =
+   WorldPos (worldTopX + playerX, worldTopY - playerY)
+
+
+worldCoordToPlayer :: WorldPos -> WorldPos -> PlayerPos
+worldCoordToPlayer (WorldPos (worldTopX, worldTopY)) (WorldPos (worldX, worldY)) =
+   PlayerPos (worldX - worldTopX, -(worldY - worldTopY))
+
+  
+drawTilesForPlayer :: World -> Map WorldPos Entity -> Map PlayerPos Tile
+drawTilesForPlayer world entityMap =
+  let
+    player = world ^. wdPlayer
+    
+    -- Top left of player's grid
+    (WorldPos (topX, topY)) = player ^. plWorldTopLeft
+
+    -- Players screen/grid dimensions
+    (screenX, screenY) = player ^. plScreenSize
+
+    -- Bottom right corner
+    (bottomX, bottomY) = (topX + screenX, topY - screenY)
+
+      -- Filter out blank
+    noEmptyMap = Map.filter (\e -> e ^. enTile ^. tlName /= "blank") entityMap
+
+    -- Only get the entitys that are at positions on the player's screen
+    visibleEntitys = Map.filterWithKey (inView topX topY bottomX bottomY) noEmptyMap
+
+    -- Get the tile for each entity
+    tileMap = (^. enTile) <$> visibleEntitys
+  in
+  -- Get it with player positions
+  Map.mapKeys (worldCoordToPlayer $ player ^. plWorldTopLeft) tileMap
+
+  where
+    inView topX topY bottomX bottomY (WorldPos (x, y)) _ =
+      x >= topX && x < bottomX && y > bottomY && y <= topY
